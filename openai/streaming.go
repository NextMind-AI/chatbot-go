package openai

import (
	"chatbot/elevenlabs"
	"chatbot/redis"
	"chatbot/vonage"
	"context"
	"encoding/json"
	"strings"

	"github.com/openai/openai-go"
	"github.com/rs/zerolog/log"
)

// streamingConfig holds the configuration for a streaming chat completion request.
type streamingConfig struct {
	userID           string
	chatHistory      []redis.ChatMessage
	vonageClient     *vonage.Client
	redisClient      *redis.Client
	elevenLabsClient *elevenlabs.Client
	toNumber         string
}

// ProcessChatStreaming processes a chat conversation with streaming response.
// It sends messages to the user via WhatsApp as they are generated by the AI.
// This method does not use any tools.
func (c *Client) ProcessChatStreaming(
	ctx context.Context,
	userID string,
	chatHistory []redis.ChatMessage,
	vonageClient *vonage.Client,
	redisClient *redis.Client,
	elevenLabsClient *elevenlabs.Client,
	toNumber string,
) error {
	config := streamingConfig{
		userID:           userID,
		chatHistory:      chatHistory,
		vonageClient:     vonageClient,
		redisClient:      redisClient,
		elevenLabsClient: elevenLabsClient,
		toNumber:         toNumber,
	}
	return c.processStreamingChat(ctx, config)
}

// ProcessChatStreamingWithTools processes a chat conversation with the new two-step approach:
// First, it uses a sleep analyzer to determine wait time, then generates the actual response.
func (c *Client) ProcessChatStreamingWithTools(
	ctx context.Context,
	userID string,
	chatHistory []redis.ChatMessage,
	vonageClient *vonage.Client,
	redisClient *redis.Client,
	elevenLabsClient *elevenlabs.Client,
	toNumber string,
) error {
	config := streamingConfig{
		userID:           userID,
		chatHistory:      chatHistory,
		vonageClient:     vonageClient,
		redisClient:      redisClient,
		elevenLabsClient: elevenLabsClient,
		toNumber:         toNumber,
	}
	return c.ExecuteSleepAndRespond(ctx, config)
}

// processStreamingChat handles the core streaming logic.
// Since tools are no longer used, this simply converts history and streams the response.
func (c *Client) processStreamingChat(ctx context.Context, config streamingConfig) error {
	messages := convertChatHistory(config.chatHistory)
	return c.streamResponse(ctx, config, messages)
}

// streamResponse creates a streaming chat completion and sends messages via WhatsApp as they arrive.
// It handles the parsing of streamed JSON and manages message deduplication with guaranteed ordering.
func (c *Client) streamResponse(
	ctx context.Context,
	config streamingConfig,
	messages []openai.ChatCompletionMessageParamUnion,
) error {
	schemaParam := createSchemaParam()

	stream := c.client.Chat.Completions.NewStreaming(ctx, openai.ChatCompletionNewParams{
		Messages: messages,
		ResponseFormat: openai.ChatCompletionNewParamsResponseFormatUnion{
			OfJSONSchema: &openai.ResponseFormatJSONSchemaParam{JSONSchema: schemaParam},
		},
		Model: openai.ChatModelGPT4_1Mini,
	})

	parser := NewStreamingJSONParser()
	var fullContent strings.Builder
	sentMessages := make(map[int]bool)

	messageQueue := make(chan messageWithIndex, 100)
	done := make(chan struct{})

	go func() {
		defer close(done)
		c.sendMessagesSequentially(ctx, config, messageQueue)
	}()

	for stream.Next() {
		evt := stream.Current()
		if len(evt.Choices) > 0 {
			content := evt.Choices[0].Delta.Content
			fullContent.WriteString(content)

			newMessages := parser.AddChunk(content)

			for i, msg := range newMessages {
				messageIndex := parser.MsgCount - len(newMessages) + i
				if !sentMessages[messageIndex] {
					sentMessages[messageIndex] = true

					log.Info().
						Str("user_id", config.userID).
						Int("message_index", messageIndex).
						Str("content", msg.Content).
						Str("type", msg.Type).
						Msg("Queueing streamed message for sequential sending")

					select {
					case messageQueue <- messageWithIndex{
						message: msg,
						index:   messageIndex,
					}:
					case <-ctx.Done():
						close(messageQueue)
						<-done
						return ctx.Err()
					}
				}
			}
		}
	}

	close(messageQueue)
	<-done

	if err := stream.Err(); err != nil {
		return err
	}

	return c.finalizeStreamingResponse(config.userID, fullContent.String(), config.redisClient)
}

// messageWithIndex wraps a message with its index for ordered processing
type messageWithIndex struct {
	message Message
	index   int
}

// sendMessagesSequentially processes messages from the queue one at a time to ensure ordering
func (c *Client) sendMessagesSequentially(
	ctx context.Context,
	config streamingConfig,
	messageQueue <-chan messageWithIndex,
) {
	for msgWithIndex := range messageQueue {
		msg := msgWithIndex.message
		messageIndex := msgWithIndex.index

		log.Info().
			Str("user_id", config.userID).
			Int("message_index", messageIndex).
			Str("content", msg.Content).
			Str("type", msg.Type).
			Msg("Sending message sequentially")

		if msg.Type == "audio" {
			audioURL, err := config.elevenLabsClient.ConvertTextToSpeechDefault(
				msg.Content,
			)
			if err != nil {
				log.Error().
					Err(err).
					Str("user_id", config.userID).
					Str("content", msg.Content).
					Int("message_index", messageIndex).
					Msg("Error converting text to speech")
				continue
			}

			response, err := config.vonageClient.SendWhatsAppAudioMessage(
				config.toNumber,
				audioURL,
			)
			if err != nil {
				log.Error().
					Err(err).
					Str("user_id", config.userID).
					Str("to", config.toNumber).
					Str("audio_url", audioURL).
					Int("message_index", messageIndex).
					Msg("Error sending WhatsApp audio message")
			} else {
				log.Info().
					Str("user_id", config.userID).
					Str("message_uuid", response.MessageUUID).
					Str("audio_url", audioURL).
					Int("message_index", messageIndex).
					Msg("Sent audio message via Vonage in sequence")
			}
		} else {
			response, err := config.vonageClient.SendWhatsAppTextMessage(
				config.toNumber,
				msg.Content,
			)
			if err != nil {
				log.Error().
					Err(err).
					Str("user_id", config.userID).
					Str("to", config.toNumber).
					Str("content", msg.Content).
					Int("message_index", messageIndex).
					Msg("Error sending WhatsApp text message")
			} else {
				log.Info().
					Str("user_id", config.userID).
					Str("message_uuid", response.MessageUUID).
					Str("content", msg.Content).
					Int("message_index", messageIndex).
					Msg("Sent text message via Vonage in sequence")
			}
		}

		select {
		case <-ctx.Done():
			log.Info().
				Str("user_id", config.userID).
				Msg("Context cancelled, stopping message sending")
			return
		default:
		}
	}
}

// finalizeStreamingResponse validates the final JSON response and stores it in Redis.
// It ensures the complete response is properly formatted and saved for chat history.
func (c *Client) finalizeStreamingResponse(
	userID string,
	fullContent string,
	redisClient *redis.Client,
) error {
	var messageList MessageList
	if err := json.Unmarshal([]byte(fullContent), &messageList); err != nil {
		log.Error().
			Err(err).
			Str("user_id", userID).
			Str("content", fullContent).
			Msg("Error parsing final JSON response")
		return err
	}

	allMessagesContent := []string{}
	for _, msg := range messageList.Messages {
		allMessagesContent = append(allMessagesContent, msg.Content)
	}
	fullResponse := strings.Join(allMessagesContent, "\n\n")

	if err := redisClient.AddBotMessage(userID, fullResponse); err != nil {
		log.Error().
			Err(err).
			Str("user_id", userID).
			Msg("Error storing bot message in Redis")
	}

	return nil
}
