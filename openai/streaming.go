package openai

import (
	"chatbot/elevenlabs"
	"chatbot/redis"
	"chatbot/vonage"
	"context"
	"encoding/json"
	"strings"

	"github.com/openai/openai-go"
	"github.com/rs/zerolog/log"
)

// streamingConfig holds the configuration for a streaming chat completion request.
type streamingConfig struct {
	userID           string
	chatHistory      []redis.ChatMessage
	vonageClient     *vonage.Client
	redisClient      *redis.Client
	elevenLabsClient *elevenlabs.Client
	toNumber         string
}

// ProcessChatStreaming processes a chat conversation with streaming response.
// It sends messages to the user via WhatsApp as they are generated by the AI.
// This method does not use any tools.
func (c *Client) ProcessChatStreaming(
	ctx context.Context,
	userID string,
	chatHistory []redis.ChatMessage,
	vonageClient *vonage.Client,
	redisClient *redis.Client,
	elevenLabsClient *elevenlabs.Client,
	toNumber string,
) error {
	config := streamingConfig{
		userID:           userID,
		chatHistory:      chatHistory,
		vonageClient:     vonageClient,
		redisClient:      redisClient,
		elevenLabsClient: elevenLabsClient,
		toNumber:         toNumber,
	}
	return c.processStreamingChat(ctx, config)
}

// ProcessChatStreamingWithTools processes a chat conversation with the new two-step approach:
// First, it uses a sleep analyzer to determine wait time, then generates the actual response.
func (c *Client) ProcessChatStreamingWithTools(
	ctx context.Context,
	userID string,
	chatHistory []redis.ChatMessage,
	vonageClient *vonage.Client,
	redisClient *redis.Client,
	elevenLabsClient *elevenlabs.Client,
	toNumber string,
) error {
	config := streamingConfig{
		userID:           userID,
		chatHistory:      chatHistory,
		vonageClient:     vonageClient,
		redisClient:      redisClient,
		elevenLabsClient: elevenLabsClient,
		toNumber:         toNumber,
	}
	return c.ExecuteSleepAndRespond(ctx, config)
}

// processStreamingChat handles the core streaming logic.
// Since tools are no longer used, this simply converts history and streams the response.
func (c *Client) processStreamingChat(ctx context.Context, config streamingConfig) error {
	messages := convertChatHistory(config.chatHistory)
	return c.streamResponse(ctx, config, messages)
}

// streamResponse creates a streaming chat completion and sends messages via WhatsApp as they arrive.
// It handles the parsing of streamed JSON and manages message deduplication.
func (c *Client) streamResponse(
	ctx context.Context,
	config streamingConfig,
	messages []openai.ChatCompletionMessageParamUnion,
) error {
	schemaParam := createSchemaParam()

	stream := c.client.Chat.Completions.NewStreaming(ctx, openai.ChatCompletionNewParams{
		Messages: messages,
		ResponseFormat: openai.ChatCompletionNewParamsResponseFormatUnion{
			OfJSONSchema: &openai.ResponseFormatJSONSchemaParam{JSONSchema: schemaParam},
		},
		Model: openai.ChatModelGPT4_1Mini,
	})

	parser := NewStreamingJSONParser()
	var fullContent strings.Builder
	sentMessages := make(map[int]bool)

	for stream.Next() {
		evt := stream.Current()
		if len(evt.Choices) > 0 {
			content := evt.Choices[0].Delta.Content
			fullContent.WriteString(content)

			newMessages := parser.AddChunk(content)

			for i, msg := range newMessages {
				messageIndex := parser.MsgCount - len(newMessages) + i
				if !sentMessages[messageIndex] {
					sentMessages[messageIndex] = true

					log.Info().
						Str("user_id", config.userID).
						Int("message_index", messageIndex).
						Str("content", msg.Content).
						Str("type", msg.Type).
						Msg("Processing streamed message")

					if msg.Type == "audio" {
						audioURL, err := config.elevenLabsClient.ConvertTextToSpeechDefault(
							msg.Content,
						)
						if err != nil {
							log.Error().
								Err(err).
								Str("user_id", config.userID).
								Str("content", msg.Content).
								Msg("Error converting text to speech")
							continue
						}

						response, err := config.vonageClient.SendWhatsAppAudioMessage(
							config.toNumber,
							audioURL,
						)
						if err != nil {
							log.Error().
								Err(err).
								Str("user_id", config.userID).
								Str("to", config.toNumber).
								Str("audio_url", audioURL).
								Msg("Error sending WhatsApp audio message")
						} else {
							log.Info().
								Str("user_id", config.userID).
								Str("message_uuid", response.MessageUUID).
								Str("audio_url", audioURL).
								Msg("Sent audio message via Vonage")
						}
					} else {
						response, err := config.vonageClient.SendWhatsAppTextMessage(
							config.toNumber,
							msg.Content,
						)
						if err != nil {
							log.Error().
								Err(err).
								Str("user_id", config.userID).
								Str("to", config.toNumber).
								Str("content", msg.Content).
								Msg("Error sending WhatsApp text message")
						} else {
							log.Info().
								Str("user_id", config.userID).
								Str("message_uuid", response.MessageUUID).
								Str("content", msg.Content).
								Msg("Sent text message via Vonage")
						}
					}
				}
			}
		}
	}

	if err := stream.Err(); err != nil {
		return err
	}

	return c.finalizeStreamingResponse(config.userID, fullContent.String(), config.redisClient)
}

// finalizeStreamingResponse validates the final JSON response and stores it in Redis.
// It ensures the complete response is properly formatted and saved for chat history.
func (c *Client) finalizeStreamingResponse(
	userID string,
	fullContent string,
	redisClient *redis.Client,
) error {
	var messageList MessageList
	if err := json.Unmarshal([]byte(fullContent), &messageList); err != nil {
		log.Error().
			Err(err).
			Str("user_id", userID).
			Str("content", fullContent).
			Msg("Error parsing final JSON response")
		return err
	}

	allMessagesContent := []string{}
	for _, msg := range messageList.Messages {
		allMessagesContent = append(allMessagesContent, msg.Content)
	}
	fullResponse := strings.Join(allMessagesContent, "\n\n")

	if err := redisClient.AddBotMessage(userID, fullResponse); err != nil {
		log.Error().
			Err(err).
			Str("user_id", userID).
			Msg("Error storing bot message in Redis")
	}

	return nil
}
